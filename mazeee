#include "cs1010.h"
#include <stdbool.h>
#include <unistd.h>
void maze(char **save, long **freq, long *step, char **line, long m, long n, long curr_row, long curr_col);
bool visit_before(long **freq, long row, long col);
void print_maze(char **line, long m, long *step);

int main() {
  long m = cs1010_read_long();
  long n = cs1010_read_long();
  char **line;
  line = calloc (m, sizeof(char *));
  long **freq;
  freq = calloc(m, sizeof(long *));
  char **save;
  save = calloc(m, sizeof(char *));
  for (long i = 0; i < m; i += 1)
  {
    line[i] = cs1010_read_word();
    freq[i] = calloc(n, sizeof(long));
    save[i] = line[i];
  }
  long curr_row = 0;
  long curr_col = 0;
  for (long i = 0; i < m; i += 1)
  {
    for (long j = 0; j < n; j += 1)
    {
      if (line[i][j] - '@' == 0) {
        curr_row = i;
        curr_col = j;
      }
    }
  }
  long step = 0;
  cs1010_println_long(curr_row);
  cs1010_println_long(curr_col);
  maze(save, freq, &step, line, m, n, curr_row, curr_col);
}

void print_maze(char **line, long m, long *step) //long step)
{
  char clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H', '\0'};
  cs1010_print_string(clear_screen);
  for (long i = 0; i < m; i += 1)
  {
    cs1010_println_string(line[i]);
  }
  cs1010_println_long(*step);
  usleep(100*1000);
}

void maze(char **save, long **freq, long *step, char **line, long m, long n, long curr_row, long curr_col)
{
  bool static has_escaped = false;
  if (curr_col  == 0 || curr_col == n-1 || curr_row  == 0 || curr_row == m-1)
  {
    print_maze(line, m, step);
    has_escaped=true;
    return;
  }
  print_maze(line, m, step);
  char up = line[curr_row - 1][curr_col];
  char right = line[curr_row][curr_col + 1];
  char down = line[curr_row + 1][curr_col];
  char left = line[curr_row][curr_col - 1];

  if (!visit_before(freq, curr_row-1, curr_col) && up == '.')
  {
    line [curr_row-1][curr_col] = '@';
    line[curr_row][curr_col] = '.';
    freq[curr_row][curr_col] = 1;
    freq[curr_row-1][curr_col] = 1;
    *step += 1;
    maze(save, freq, step, line, m, n, curr_row-1, curr_col);
    if (has_escaped == false)
    {
      line[curr_row][curr_col] = '@';
      line[curr_row-1][curr_col] = '.';
      *step += 1;
      maze(save,freq, step, line, m, n, curr_row, curr_col);
    }

  } else if (!visit_before(freq, curr_row, curr_col+1) && right == '.')
  {
    line[curr_row][curr_col+1] = '@';
    line[curr_row][curr_col] = '.';
    freq[curr_row][curr_col] = 1;
    freq[curr_row][curr_col+1] = 1;
    *step += 1;
    maze(save, freq, step, line, m, n, curr_row, curr_col + 1);
    if (has_escaped == false)
    {
      line[curr_row][curr_col] = '@';
      line[curr_row][curr_col+1] = '.';
      *step += 1;
      maze(save,freq, step, line, m, n, curr_row, curr_col);
    }
  } else if (!visit_before(freq, curr_row+1, curr_col) && down == '.')
  {
    line[curr_row + 1][curr_col] = '@';
    line[curr_row][curr_col] = '.';
    freq[curr_row][curr_col] = 1;
    freq[curr_row+1][curr_col] = 1;
    *step += 1;
    maze(save, freq, step, line, m, n, curr_row+1, curr_col);
    if (has_escaped == false)
    {
      line[curr_row][curr_col] = '@';
      line[curr_row+1][curr_col] = '.';
      *step += 1;
      maze(save,freq, step, line, m, n, curr_row, curr_col);
    }
  } else if (!visit_before(freq, curr_row, curr_col-1) && left == '.')
  {
    line[curr_row][curr_col - 1] = '@';
    line[curr_row][curr_col] = '.';
    freq[curr_row][curr_col] = 1;
    freq[curr_row][curr_col-1] = 1;
    *step += 1;
    maze(save, freq, step, line, m, n, curr_row, curr_col - 1);
    if (has_escaped == false)
    {
      line[curr_row][curr_col] = '@';
      line[curr_row][curr_col-1] = '.';
      *step += 1;
      maze(save,freq, step, line, m, n, curr_row, curr_col);
    }
  }
}

bool visit_before(long **freq, long row, long col)
{
  if (freq[row][col] == 1)
  {
    return true;
  }
  return false;
}


